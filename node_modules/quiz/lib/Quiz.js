/*global require module console setTimeout clearTimeout*/
(function(){"use strict";
	var cs = require('cornerstone'),
	    util = cs.require('util'),
	    Class = cs.require('Class'),
	    Emitter = cs.require('Emitter');
	var Quiz = module.exports = Class.create('Quiz', Emitter, function (obj, proto) {
		obj.initQuiz = function (name, proc, parent) {
			this.initEmitter();
			if (typeof name !== 'string') {
				throw 'Cannot create a Quiz without a name.';
			}
			this.name = name;
			this.parent = this;
			this.childs = {};
			this.asserts = {async: [], synch: []};
			this.results = {};
			if (Quiz.check(parent)) {
				parent.add(this);
			}
			if (util.isFunction(proc)) {
				proc.call(this);
			}
			return this;
		};
		obj.add = function (test) {
			if (!Quiz.check(test)) return this;
			if (!Quiz.check(this.childs[test.name])) {
				this.childs[test.name] = test;
				test.parent = this;
			}
			return this;
		};
		obj.test = function (name, proc) {
			return new Quiz(name, proc, this);
		};
		obj.assert = function (proc) {
			if (util.isFunction(proc)) {
				proc.type = 'synch';
				proc.index = this.asserts.synch.length;
				this.asserts.synch.push(proc);
			}
			return this;
		};
		obj.async = function (proc) {
			if (util.isFunction(proc)) {
				proc.type = 'async';
				proc.index = this.asserts.async.length;
				this.asserts.async.push(proc);
			}
			return this;
		};
		obj.children = function (iterator, bind) {
			var name, child;
			if (util.isFunction(iterator)) {
				for (name in this.childs) {
					child = this.childs[name];
					if (Quiz.check(child)) {
						iterator.call(bind || child, child, name, this.childs);
					}
				}
			}
			return this;
		};
		obj.childList = function () {
			var list = [];
			this.children(function (child) {
				list.push(child);
			});
			return list;
		};
		obj.check = function (result) {
			if (result === null || result === undefined || result === false) {
				return false;
			}
			if (result.failed) return false;
			if (result instanceof Error) return false;
			if (/Error/.test(({}).toString.call(result))) return false;
			return true;
		};
		obj.log = function () {
			if (this.debug) {
				console.log.apply(console, arguments);
			}
			return this;
		};
		obj.run = function (callback, updater, amount, timeout) {
			this.log(this.name + ': running tests');
			this.results = {passed: [], failed: [], total: 0, started: (+new Date()), elapsed: 0};
			amount = isFinite(amount) ? amount : 1;
			var that = this,
			    count = 0,
			    timer = null,
			    time,
			    proc,
			    ind = 0,
			    end = this.asserts.synch.length,
			    cb,
			    n;
			this.log(this.name + ': ' + end + ' synchronous assertions');
			for (; ind < end; ind += 1) {
				proc = this.asserts.synch[ind];
				if (util.isFunction(proc)) {
					try {
						time = (+new Date());
						n = amount - 1;
						while (n--) proc.call(this);
						proc.result = proc.call(this);
						time = ((+new Date()) - time);
						this.results.elapsed += time;
						proc.elapsed = time / amount;
					} catch (e0) {
						proc.result = e0;
						proc.elapsed = 0;
					}
					if (this.check(proc.result)) {
						this.results.passed.push(proc);
					} else {
						this.results.failed.push(proc);
					}
					this.results.total += 1;
					if (util.isFunction(updater)) {
						updater.call(that, proc);
					}
				}
			}
			ind = 0;
			end = this.asserts.async.length;
			for (; ind < end; ind += 1) {
				if (util.isFunction(this.asserts.async[ind])) {
					count += 1;
				}
			}
			this.log(this.name + ': ' + count + ' asynchronous assertions');
			this.children(function () {
				count += 1;
			});
			this.log(this.name + ': final count asynchronous assertions plus subtests: ' + count);
			function sendCallback (that) {
				var started,
				    elapsed,
				    ended,
				    run;
				if (count === 0 && util.isFunction(callback)) {
					clearTimeout(timer);
					that.log(that.name + ': finished');
					run = that.run;
					ended = that.results.ended = (+new Date());
					started = that.results.started;
					elapsed = that.results.elapsed;
					that.rerun = run;
					that.run = function (callback) {
						callback.call(this, this);
						return this;
					};
					callback.call(that, that);
				}
			}
			function reduceCount (that) {
				count -= 1;
				that.log(that.name + ': reduce count to ' + count);
				sendCallback(that);
			}
			if (isFinite(timeout)) {
				timer = setTimeout(function () {
					that.log(that.name + ': timed out');
					count = 0;
					sendCallback(that);
				}, timeout);
			}
			sendCallback(this);
			ind = 0;
			end = this.asserts.async.length;
			function procCallback (proc, that) {
				var time = (+new Date()),
				    cnt = amount - 1;
				return function (result) {
					cnt -= 1;
					proc.elapsed += (+new Date()) - time;
					proc.result = result;
					if (cnt === 0) {
						that.results.elapsed += proc.elapsed;
						proc.elapsed /= amount;
						if (that.check(result)) {
							that.results.failed.splice(proc.failedIndex, 1);
							that.results.passed.push(proc);
						}
						delete proc.failedIndex;
						if (util.isFunction(updater)) {
							updater.call(that, proc);
						}
						that.log(that.name + ': reduced from assertion');
						reduceCount(that);
					}
				};
			}
			for (; ind < end; ind += 1) {
				proc = this.asserts.async[ind];
				if (util.isFunction(proc)) {
					try {
						proc.elapsed = 0;
						proc.result = new Error('Waiting for response');
						proc.failedIndex = this.results.failed.length;
						this.results.failed.push(proc);
						cb = procCallback(proc, this);
						n = amount;
						while (n--) proc.call(this, cb);
					} catch (e1) {
						proc.elapsed = 0;
						proc.result = e1;
						reduceCount.call(this);
					}
					this.results.total += 1;
				}
			}
			this.log(this.name + ': ' + this.results.total + ' tests');
			this.children(function (test) {
				test.run(function () {
					that.log(that.name + ': reduced from subtest');
					reduceCount(that);
				}, updater, amount);
			});
			return this;
		};
		obj.report = function (iterator, callback, state, updater, amount, timeout) {
			state = state || {};
			this.log(this.name + ': report');
			return this.run(function () {
				util.safeApply(iterator, this, [state]);
				var count = 0;
				this.children(function () {
					count += 1;
				});
				this.log(this.name + ': ' + count + ' subtests counted');
				if (count > 0) {
					this.children(function (test) {
						var that = this;
						test.report(iterator, function () {
							count -= 1;
							that.log(that.name + ': reduce subtest count to ' + count);
							if (count === 0) {
								that.log(that.name + ': report finished');
								util.safeApply(callback, that, [that]);
							}
						}, Object.create(state));
					}, this);
				} else {
					util.safeApply(callback, this, [this]);
				}
			}, updater, amount, timeout);
		};
		obj.reportLog = function (callback, showPassed, amount, timeout) {
			var started = (+new Date()),
			    elapsed = 0,
			    failed = 0,
			    total = 0,
			    clean = this.cleanLeftSpace;
			if (!isFinite(timeout)) timeout = 2500;
			return this.report(
				function (state) {
					if (!this.name) return this;
					var name = state.name = state.name ? this.joinName(state.name) : this.name,
					    tabs = state.tabs = state.tabs ? (state.tabs + '  ') : String.fromCharCode(0);
					function showProc (proc) {
						console.log(tabs + '  assert ' + clean(proc.toString()));
						console.log(tabs + '    result ' + proc.result);
						console.log(tabs + '    ' + proc.elapsed + ' ms');
					}
					if (this.results.failed.length) {
						console.error(tabs + 'failed "' + name + '"');
						util.enumerate(this.results.failed, showProc);
					} else if (showPassed) {
						console.log(tabs + 'passed "' + name + '"');
					}
					if (showPassed) {
						util.enumerate(this.results.passed, showProc, this);
					}
					elapsed += this.results.elapsed;
					failed += this.results.failed.length;
					total += this.results.total;
				},
				function () {
					if (failed) {
						console.error(failed + '/' + total + ' failed');
					} else {
						console.log((total - failed) + '/' + total + ' passed');
					}
					console.log(elapsed + ' ms (assertion time)');
					console.log((this.results.ended - this.results.started) + ' ms (run time)');
					console.log(((+new Date()) - started) + ' ms (report time)');
					util.safeApply(callback, this, [this]);
				},
				null,
				function () {
					//console.log('.');
				},
				amount,
				timeout
			);
		};
		obj.joinName = function (stateName, name) {
			var delim = (stateName.charAt(stateName.length - 1) === ':') ?
				' ' : '.';
			if (delim === '.' && (/\s/).test(stateName)) {
				stateName += ':';
				delim = ' ';
			}
			return stateName + delim + this.name;
		};
		obj.cleanLeftSpace = function (str) {
			var left = (/(?:^|[\n\r])([\t\u00A0\u2028\u2029]+)/).exec(str);
			if (!left) return str;
			left = left[1];
			left = left.substr(0, left.length - (left.charAt(left.length - 1) === '\t' ? 1 : 2));
			var trim = new RegExp('(^|[\n\r])' + left, 'g');
			return str.replace(trim, function (m, n) {
				return n;
			});
		};
	});
}).call(this);